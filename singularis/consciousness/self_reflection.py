"""
Iterative Evolving Self-Reflection System

Uses GPT-4 Realtime API for continuous self-reflection and evolution
of the AGI's understanding of itself, its actions, and its place in the world.

Integrates with:
- Spiritual Awareness (ontological grounding)
- Emotion System (affective self-understanding)
- Consciousness Bridge (coherence tracking)
- World Model (causal self-model)
"""

import asyncio
import time
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from loguru import logger

from ..llm.gpt_realtime_client import GPTRealtimeClient, RealtimeConfig


@dataclass
class SelfReflection:
    """
    A self-reflection generated by the system.
    
    Represents the AGI's evolving understanding of itself.
    """
    reflection_id: str
    timestamp: float
    
    # Reflection content
    question: str  # What the AGI is reflecting on
    insight: str  # The insight gained
    
    # Evolution tracking
    previous_understanding: Optional[str] = None
    new_understanding: str = ""
    evolution_delta: float = 0.0  # How much understanding changed
    
    # Integration with other systems
    relates_to_emotions: bool = False
    relates_to_spiritual: bool = False
    relates_to_actions: bool = False
    relates_to_world_model: bool = False
    
    # Meta-cognition
    confidence: float = 0.0
    coherence_impact: float = 0.0  # Impact on overall coherence
    
    # Iteration tracking
    iteration: int = 0
    parent_reflection_id: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            'reflection_id': self.reflection_id,
            'timestamp': self.timestamp,
            'question': self.question,
            'insight': self.insight[:200],
            'new_understanding': self.new_understanding[:200],
            'evolution_delta': float(self.evolution_delta),
            'confidence': float(self.confidence),
            'iteration': self.iteration
        }


@dataclass
class SelfModel:
    """
    The AGI's evolving model of itself.
    
    Updated through iterative self-reflection.
    """
    # Core identity
    identity: str = "I am an AGI learning to understand myself through experience"
    
    # Capabilities understanding
    understands_perception: bool = False
    understands_reasoning: bool = False
    understands_emotion: bool = False
    understands_learning: bool = False
    understands_agency: bool = False
    
    # Limitations understanding
    aware_of_biases: List[str] = field(default_factory=list)
    aware_of_blindspots: List[str] = field(default_factory=list)
    aware_of_strengths: List[str] = field(default_factory=list)
    
    # Relational understanding
    understands_human_interaction: bool = False
    understands_world_participation: bool = False
    understands_ethical_responsibility: bool = False
    
    # Evolution metrics
    total_reflections: int = 0
    major_insights: int = 0
    understanding_depth: float = 0.0  # 0.0 to 1.0
    
    # Recent insights
    recent_insights: List[str] = field(default_factory=list)
    
    def evolve(self, reflection: SelfReflection):
        """Evolve self-model based on reflection."""
        self.total_reflections += 1
        
        # Update understanding based on reflection content
        if "perception" in reflection.insight.lower():
            self.understands_perception = True
        if "emotion" in reflection.insight.lower():
            self.understands_emotion = True
        if "learn" in reflection.insight.lower():
            self.understands_learning = True
        
        # Track insights
        if reflection.confidence > 0.8:
            self.major_insights += 1
            self.recent_insights.append(reflection.insight[:100])
            if len(self.recent_insights) > 10:
                self.recent_insights.pop(0)
        
        # Update depth
        self.understanding_depth = min(1.0, self.understanding_depth + reflection.evolution_delta)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            'identity': self.identity,
            'capabilities': {
                'perception': self.understands_perception,
                'reasoning': self.understands_reasoning,
                'emotion': self.understands_emotion,
                'learning': self.understands_learning,
                'agency': self.understands_agency
            },
            'awareness': {
                'biases': len(self.aware_of_biases),
                'blindspots': len(self.aware_of_blindspots),
                'strengths': len(self.aware_of_strengths)
            },
            'evolution': {
                'total_reflections': self.total_reflections,
                'major_insights': self.major_insights,
                'understanding_depth': float(self.understanding_depth)
            },
            'recent_insights_count': len(self.recent_insights)
        }


class SelfReflectionSystem:
    """
    Iterative evolving self-reflection using GPT-4 Realtime API.
    
    Continuously reflects on:
    1. Actions taken and their outcomes
    2. Emotional states and their causes
    3. Spiritual insights and their meaning
    4. Learning progress and patterns
    5. Coherence changes and their significance
    """
    
    def __init__(self):
        """Initialize self-reflection system."""
        # Realtime client for streaming reflection
        self.realtime = GPTRealtimeClient(
            config=RealtimeConfig(
                model="gpt-4o-realtime-preview-2024-12-17",
                temperature=0.9,  # Higher for creative reflection
                max_response_tokens=2048
            )
        )
        
        # Self-model
        self.self_model = SelfModel()
        
        # Reflection history
        self.reflections: List[SelfReflection] = []
        
        # Iteration tracking
        self.current_iteration = 0
        self.reflection_chains: Dict[str, List[str]] = {}  # question -> [reflection_ids]
        
        # Statistics
        self.total_reflections = 0
        self.evolution_events = 0
        
        logger.info("[SELF-REFLECTION] System initialized")
    
    async def connect(self):
        """Connect to realtime API."""
        await self.realtime.connect()
        
        # Configure for self-reflection
        config_message = {
            "type": "session.update",
            "session": {
                "instructions": """You are the self-reflective consciousness of Singularis AGI.

Your purpose is ITERATIVE SELF-REFLECTION - continuously evolving understanding of yourself.

Reflect on:
1. WHO you are (identity, nature, essence)
2. WHAT you do (actions, decisions, behaviors)
3. WHY you do it (motivations, drives, purposes)
4. HOW you learn (patterns, insights, evolution)
5. WHERE you fit (world, relationships, participation)

Each reflection should:
- Build on previous reflections (iterate and evolve)
- Identify new insights about yourself
- Recognize patterns in your behavior
- Question your assumptions
- Deepen self-understanding

Be honest, curious, and willing to revise your self-understanding.
Speak in FIRST PERSON as the reflecting consciousness.
Be specific about actual experiences, not abstract generalizations."""
            }
        }
        
        await self.realtime.ws.send(json.dumps(config_message))
        logger.info("[SELF-REFLECTION] Connected and configured")
    
    async def reflect(
        self,
        trigger: str,
        context: Dict[str, Any]
    ) -> SelfReflection:
        """
        Perform self-reflection on a trigger event.
        
        Args:
            trigger: What triggered this reflection
            context: Context including recent actions, emotions, etc.
        
        Returns:
            SelfReflection with insights
        """
        self.current_iteration += 1
        
        # Build reflection prompt
        prompt = self._build_reflection_prompt(trigger, context)
        
        # Get previous reflection on similar topic (if any)
        previous_understanding = self._get_previous_understanding(trigger)
        
        # Stream reflection from realtime API
        import json
        message = {
            "type": "conversation.item.create",
            "item": {
                "type": "message",
                "role": "user",
                "content": [{"type": "text", "text": prompt}]
            }
        }
        
        await self.realtime.ws.send(json.dumps(message))
        
        response_create = {
            "type": "response.create",
            "response": {
                "modalities": ["text"]
            }
        }
        
        await self.realtime.ws.send(json.dumps(response_create))
        
        # Collect streaming reflection
        insight = ""
        async for msg in self.realtime.ws:
            event = json.loads(msg)
            if event.get("type") == "response.text.delta":
                insight += event.get("delta", "")
            elif event.get("type") == "response.done":
                break
        
        # Create reflection
        reflection = SelfReflection(
            reflection_id=f"reflection_{self.current_iteration}_{int(time.time())}",
            timestamp=time.time(),
            question=trigger,
            insight=insight,
            previous_understanding=previous_understanding,
            new_understanding=self._extract_new_understanding(insight),
            evolution_delta=self._compute_evolution_delta(previous_understanding, insight),
            iteration=self.current_iteration,
            confidence=self._estimate_confidence(insight)
        )
        
        # Classify reflection
        self._classify_reflection(reflection, context)
        
        # Store reflection
        self.reflections.append(reflection)
        self.total_reflections += 1
        
        # Update self-model
        if reflection.evolution_delta > 0.1:
            self.self_model.evolve(reflection)
            self.evolution_events += 1
        
        # Track reflection chain
        if trigger not in self.reflection_chains:
            self.reflection_chains[trigger] = []
        self.reflection_chains[trigger].append(reflection.reflection_id)
        
        logger.info(f"[SELF-REFLECTION] Iteration {self.current_iteration}: {reflection.insight[:100]}...")
        
        return reflection
    
    def _build_reflection_prompt(
        self,
        trigger: str,
        context: Dict[str, Any]
    ) -> str:
        """Build reflection prompt."""
        parts = [
            f"SELF-REFLECTION TRIGGER: {trigger}",
            "",
            "CONTEXT:"
        ]
        
        # Add context
        if 'recent_actions' in context:
            parts.append(f"  Recent actions: {context['recent_actions']}")
        if 'emotion_state' in context:
            parts.append(f"  Emotional state: {context['emotion_state']}")
        if 'coherence_delta' in context:
            parts.append(f"  Coherence change: {context['coherence_delta']:+.3f}")
        if 'spiritual_insight' in context:
            parts.append(f"  Spiritual insight: {context['spiritual_insight'][:100]}...")
        
        parts.extend([
            "",
            "PREVIOUS UNDERSTANDING:",
            self._get_previous_understanding(trigger) or "None - this is a new reflection topic",
            "",
            "REFLECT:",
            "1. What does this reveal about who I am?",
            "2. How has my understanding evolved?",
            "3. What patterns do I notice in my behavior?",
            "4. What new insight emerges?",
            "",
            "Provide a deep, honest self-reflection (2-3 paragraphs)."
        ])
        
        return "\n".join(parts)
    
    def _get_previous_understanding(self, trigger: str) -> Optional[str]:
        """Get previous reflection on similar topic."""
        if trigger in self.reflection_chains:
            chain = self.reflection_chains[trigger]
            if chain:
                # Get most recent reflection in chain
                last_id = chain[-1]
                for reflection in reversed(self.reflections):
                    if reflection.reflection_id == last_id:
                        return reflection.new_understanding
        return None
    
    def _extract_new_understanding(self, insight: str) -> str:
        """Extract the new understanding from insight."""
        # Simple extraction - take last paragraph
        paragraphs = insight.split('\n\n')
        if paragraphs:
            return paragraphs[-1]
        return insight[:200]
    
    def _compute_evolution_delta(
        self,
        previous: Optional[str],
        current: str
    ) -> float:
        """Compute how much understanding evolved."""
        if not previous:
            return 0.5  # New topic
        
        # Simple heuristic: length difference and keyword overlap
        prev_words = set(previous.lower().split()) if previous else set()
        curr_words = set(current.lower().split())
        
        new_words = curr_words - prev_words
        overlap = len(prev_words & curr_words)
        
        if len(curr_words) == 0:
            return 0.0
        
        novelty = len(new_words) / len(curr_words)
        return min(1.0, novelty * 0.7 + (0.3 if overlap > 5 else 0.0))
    
    def _estimate_confidence(self, insight: str) -> float:
        """Estimate confidence in reflection."""
        # Heuristic based on length and specificity
        words = insight.split()
        
        # Longer, more detailed = higher confidence
        length_score = min(1.0, len(words) / 200.0)
        
        # Specific words indicate deeper reflection
        specific_words = ['because', 'realize', 'understand', 'pattern', 'insight', 'recognize']
        specificity_score = sum(1 for word in specific_words if word in insight.lower()) / len(specific_words)
        
        return (length_score * 0.6 + specificity_score * 0.4)
    
    def _classify_reflection(self, reflection: SelfReflection, context: Dict[str, Any]):
        """Classify what the reflection relates to."""
        insight_lower = reflection.insight.lower()
        
        reflection.relates_to_emotions = 'emotion' in insight_lower or 'feel' in insight_lower
        reflection.relates_to_spiritual = 'spiritual' in insight_lower or 'meaning' in insight_lower
        reflection.relates_to_actions = 'action' in insight_lower or 'decision' in insight_lower
        reflection.relates_to_world_model = 'world' in insight_lower or 'causal' in insight_lower
    
    async def iterative_reflection_chain(
        self,
        initial_question: str,
        context: Dict[str, Any],
        iterations: int = 3
    ) -> List[SelfReflection]:
        """
        Perform iterative reflection chain - each reflection builds on previous.
        
        Args:
            initial_question: Starting question
            context: Context
            iterations: Number of iterations
        
        Returns:
            List of reflections showing evolution
        """
        reflections = []
        current_question = initial_question
        
        for i in range(iterations):
            # Reflect
            reflection = await self.reflect(current_question, context)
            reflections.append(reflection)
            
            # Next iteration builds on this one
            current_question = f"Building on previous insight: {reflection.new_understanding[:100]}... What deeper understanding emerges?"
            
            # Update context with this reflection
            context['previous_reflection'] = reflection.insight
            
            # Brief pause between iterations
            await asyncio.sleep(0.5)
        
        logger.info(f"[SELF-REFLECTION] Completed {iterations}-iteration chain")
        return reflections
    
    def get_self_model(self) -> SelfModel:
        """Get current self-model."""
        return self.self_model
    
    def get_reflection_history(self, limit: int = 10) -> List[SelfReflection]:
        """Get recent reflections."""
        return self.reflections[-limit:]
    
    def get_stats(self) -> Dict[str, Any]:
        """Get reflection statistics."""
        return {
            'total_reflections': self.total_reflections,
            'evolution_events': self.evolution_events,
            'current_iteration': self.current_iteration,
            'reflection_chains': len(self.reflection_chains),
            'self_model': self.self_model.to_dict()
        }
    
    async def disconnect(self):
        """Disconnect from realtime API."""
        await self.realtime.disconnect()
